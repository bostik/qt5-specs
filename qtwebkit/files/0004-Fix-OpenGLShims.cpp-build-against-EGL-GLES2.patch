From 1ef17f0efa2f143ffcc2fd71c142b474083d2a48 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mika=20Bostr=C3=B6m?= <bostik@odin.bostik.iki.fi>
Date: Sun, 14 Oct 2012 11:16:28 +0300
Subject: [PATCH 4/5] Fix OpenGLShims.cpp build against EGL/GLES2

This is directly picked from WebKit upstream:
commit 5f378259334c6dc4dcac599421f87c7ab8a9cad9

Author: hausmann@webkit.org

Build of OpenGLShims.cpp against EGL/GLES2 platforms is broken
https://bugs.webkit.org/show_bug.cgi?id=95556

Reviewed by Jocelyn Turcotte.

There were a few problems:

1) GL_ANGLE_framebuffer_blit is the name of the macro indicating the
availability of the _declaration_ of that ANGLE extension. It is not the
name of the actual function, which is glBlitFramebufferANGLE.

2) The presence of the preprocessor macros indicating the availability
of the declaration of the extension does not imply presence of the extension
prototypes at link time. Instead extensions need to be looked up dynamically
at run-time.

3) dlfcn.h was unconditionally included. We do not need it when building against
Qt (and there it breaks the Windows build)

This patch implements the dynamic lookup of glBlitFramebufferANGLE
(used in GraphicsContext3DOpenGLES.cpp) as well as the dynamic lookup of the
Angle and Apple renderbuffer multisampling extensions.
---
 Source/WebCore/platform/graphics/OpenGLShims.cpp |   60 ++++++++++++----------
 1 file changed, 34 insertions(+), 26 deletions(-)

diff --git a/Source/WebCore/platform/graphics/OpenGLShims.cpp b/Source/WebCore/platform/graphics/OpenGLShims.cpp
index 8e54ee4..1bde4a8 100644
--- a/Source/WebCore/platform/graphics/OpenGLShims.cpp
+++ b/Source/WebCore/platform/graphics/OpenGLShims.cpp
@@ -22,7 +22,10 @@
 #define DISABLE_SHIMS
 #include "OpenGLShims.h"
 
+#if !PLATFORM(QT)
 #include <dlfcn.h>
+#endif
+
 #include <wtf/text/CString.h>
 #include <wtf/text/WTFString.h>
 
@@ -34,11 +37,6 @@ OpenGLFunctionTable* openGLFunctionTable()
     return &table;
 }
 
-#if PLATFORM(QT) && defined(QT_OPENGL_ES_2)
-#define ASSIGN_FUNCTION_TABLE_ENTRY(FunctionName, success) \
-    openGLFunctionTable()->FunctionName = ::FunctionName
-#else
-
 #if PLATFORM(QT)
 static void* getProcAddress(const char* procName)
 {
@@ -63,9 +61,9 @@ static void* getProcAddress(const char* procName)
 }
 #endif
 
-static void* lookupOpenGLFunctionAddress(const char* functionName, bool& success)
+static void* lookupOpenGLFunctionAddress(const char* functionName, bool* success = 0)
 {
-    if (!success)
+    if (success && !*success)
         return 0;
 
     void* target = getProcAddress(functionName);
@@ -82,17 +80,39 @@ static void* lookupOpenGLFunctionAddress(const char* functionName, bool& success
     fullFunctionName.append("EXT");
     target = getProcAddress(fullFunctionName.utf8().data());
 
+#if defined(GL_ES_VERSION_2_0)
+    fullFunctionName = functionName;
+    fullFunctionName.append("ANGLE");
+    target = getProcAddress(fullFunctionName.utf8().data());
+
+    fullFunctionName = functionName;
+    fullFunctionName.append("APPLE");
+    target = getProcAddress(fullFunctionName.utf8().data());
+#endif
+
     // A null address is still a failure case.
-    if (!target)
-        success = false;
+    if (!target && success)
+        *success = false;
 
     return target;
 }
 
+#if PLATFORM(QT) && defined(QT_OPENGL_ES_2)
+
+// With Angle only EGL/GLES2 extensions are available through eglGetProcAddress, not the regular standardized functions.
+#define ASSIGN_FUNCTION_TABLE_ENTRY(FunctionName, success) \
+    openGLFunctionTable()->FunctionName = ::FunctionName
+
+#else
+
 #define ASSIGN_FUNCTION_TABLE_ENTRY(FunctionName, success) \
-    openGLFunctionTable()->FunctionName = reinterpret_cast<FunctionName##Type>(lookupOpenGLFunctionAddress(#FunctionName, success))
+    openGLFunctionTable()->FunctionName = reinterpret_cast<FunctionName##Type>(lookupOpenGLFunctionAddress(#FunctionName, &success))
+
 #endif
 
+#define ASSIGN_FUNCTION_TABLE_ENTRY_EXT(FunctionName) \
+    openGLFunctionTable()->FunctionName = reinterpret_cast<FunctionName##Type>(lookupOpenGLFunctionAddress(#FunctionName))
+
 bool initializeOpenGLShims()
 {
     static bool success = true;
@@ -111,14 +131,9 @@ bool initializeOpenGLShims()
     ASSIGN_FUNCTION_TABLE_ENTRY(glBlendEquation, success);
     ASSIGN_FUNCTION_TABLE_ENTRY(glBlendEquationSeparate, success);
     ASSIGN_FUNCTION_TABLE_ENTRY(glBlendFuncSeparate, success);
+    // In GLES2 there is optional an ANGLE extension for glBlitFramebuffer
 #if defined(GL_ES_VERSION_2_0)
-
-#if defined(GL_ANGLE_framebuffer_blit)
-    openGLFunctionTable()->glBlitFramebuffer = ::GL_ANGLE_framebuffer_blit;
-#else
-    openGLFunctionTable()->glBlitFramebuffer = 0;
-#endif
-
+    ASSIGN_FUNCTION_TABLE_ENTRY_EXT(glBlitFramebuffer);
 #else
     ASSIGN_FUNCTION_TABLE_ENTRY(glBlitFramebuffer, success);
 #endif
@@ -167,16 +182,9 @@ bool initializeOpenGLShims()
     ASSIGN_FUNCTION_TABLE_ENTRY(glIsShader, success);
     ASSIGN_FUNCTION_TABLE_ENTRY(glLinkProgram, success);
     ASSIGN_FUNCTION_TABLE_ENTRY(glRenderbufferStorage, success);
+    // In GLES2 there are optional ANGLE and APPLE extensions for glRenderbufferStorageMultisample.
 #if defined(GL_ES_VERSION_2_0)
-
-#if defined(GL_APPLE_framebuffer_multisample)
-    openGLFunctionTable()->glRenderbufferStorageMultisample = ::glRenderbufferStorageMultisampleAPPLE;
-#elif defined(GL_ANGLE_framebuffer_multisample)
-    openGLFunctionTable()->glRenderbufferStorageMultisample = ::glRenderbufferStorageMultisampleANGLE;
-#else
-    openGLFunctionTable()->glRenderbufferStorageMultisample = 0;
-#endif
-
+    ASSIGN_FUNCTION_TABLE_ENTRY_EXT(glRenderbufferStorageMultisample);
 #else
     ASSIGN_FUNCTION_TABLE_ENTRY(glRenderbufferStorageMultisample, success);
 #endif
-- 
1.7.10.4

