From 5dec60b05490f6ae1827e1e7c7c92e2a24af29bb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mika=20Bostr=C3=B6m?= <bostik@odin.bostik.iki.fi>
Date: Thu, 27 Dec 2012 12:26:36 +0200
Subject: [PATCH 9/9] Work around JSObject linker bug

Fold contents of JSDestructibleObject.h into JSObject.h, as suggested in
https://bugs.webkit.org/show_bug.cgi?id=100592#c6

Change all includes: where the code originally required
JSDestructibleObject.h, we now include JSObject.h instead. This change
allows the build to link binaries with libJavaScriptCore and get
(hopefully) sensible results.
---
 Source/JavaScriptCore/API/JSCallbackConstructor.h  |   10 +-
 Source/JavaScriptCore/JSCTypedArrayStubs.h         |    6 +-
 Source/JavaScriptCore/heap/CopyVisitorInlines.h    |    6 +-
 Source/JavaScriptCore/heap/MarkedBlock.cpp         |   14 +-
 Source/JavaScriptCore/heap/SlotVisitor.cpp         |   31 ++-
 Source/JavaScriptCore/runtime/Arguments.h          |   24 +--
 Source/JavaScriptCore/runtime/InternalFunction.h   |    8 +-
 Source/JavaScriptCore/runtime/JSFunction.h         |   18 +-
 Source/JavaScriptCore/runtime/JSObject.h           |  211 ++++++++++++--------
 Source/JavaScriptCore/runtime/JSProxy.h            |    4 +-
 Source/JavaScriptCore/runtime/JSWrapperObject.h    |    6 +-
 Source/JavaScriptCore/runtime/NameInstance.h       |    2 +-
 .../runtime/JSDestructibleObject.h                 |    2 +-
 Source/WebCore/bindings/js/JSDOMWrapper.h          |    4 +-
 14 files changed, 195 insertions(+), 151 deletions(-)

diff --git a/Source/JavaScriptCore/API/JSCallbackConstructor.h b/Source/JavaScriptCore/API/JSCallbackConstructor.h
index 2bb4d07..603cfec 100644
--- a/Source/JavaScriptCore/API/JSCallbackConstructor.h
+++ b/Source/JavaScriptCore/API/JSCallbackConstructor.h
@@ -20,14 +20,14 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef JSCallbackConstructor_h
 #define JSCallbackConstructor_h
 
 #include "JSObjectRef.h"
-#include "runtime/JSDestructibleObject.h"
+#include "JSObject.h"
 
 namespace JSC {
 
@@ -35,20 +35,20 @@ class JSCallbackConstructor : public JSDestructibleObject {
 public:
     typedef JSDestructibleObject Base;
 
-    static JSCallbackConstructor* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, JSClassRef classRef, JSObjectCallAsConstructorCallback callback) 
+    static JSCallbackConstructor* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, JSClassRef classRef, JSObjectCallAsConstructorCallback callback)
     {
         JSCallbackConstructor* constructor = new (NotNull, allocateCell<JSCallbackConstructor>(*exec->heap())) JSCallbackConstructor(globalObject, structure, classRef, callback);
         constructor->finishCreation(globalObject, classRef);
         return constructor;
     }
-    
+
     ~JSCallbackConstructor();
     static void destroy(JSCell*);
     JSClassRef classRef() const { return m_class; }
     JSObjectCallAsConstructorCallback callback() const { return m_callback; }
     static const ClassInfo s_info;
 
-    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) 
+    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
     {
         return Structure::create(globalData, globalObject, proto, TypeInfo(ObjectType, StructureFlags), &s_info);
     }
diff --git a/Source/JavaScriptCore/JSCTypedArrayStubs.h b/Source/JavaScriptCore/JSCTypedArrayStubs.h
index 2e273f6..715e0bd 100644
--- a/Source/JavaScriptCore/JSCTypedArrayStubs.h
+++ b/Source/JavaScriptCore/JSCTypedArrayStubs.h
@@ -20,13 +20,13 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef JSCTypedArrayStubs_h
 #define JSCTypedArrayStubs_h
 
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 #include "ObjectPrototype.h"
 #include <wtf/Float32Array.h>
 #include <wtf/Float64Array.h>
@@ -40,7 +40,7 @@
 #include <wtf/Uint8ClampedArray.h>
 
 namespace JSC {
-    
+
 #define TYPED_ARRAY(name, type) \
 class JS##name##Array : public JSDestructibleObject { \
 public: \
diff --git a/Source/JavaScriptCore/heap/CopyVisitorInlines.h b/Source/JavaScriptCore/heap/CopyVisitorInlines.h
index 1557af9..8d1a05c 100644
--- a/Source/JavaScriptCore/heap/CopyVisitorInlines.h
+++ b/Source/JavaScriptCore/heap/CopyVisitorInlines.h
@@ -30,7 +30,7 @@
 #include "CopyVisitor.h"
 #include "GCThreadSharedData.h"
 #include "JSCell.h"
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 
 namespace JSC {
 
@@ -56,11 +56,11 @@ inline void* CopyVisitor::allocateNewSpace(size_t bytes)
     void* result = 0; // Compilers don't realize that this will be assigned.
     if (LIKELY(m_copiedAllocator.tryAllocate(bytes, &result)))
         return result;
-    
+
     result = allocateNewSpaceSlow(bytes);
     ASSERT(result);
     return result;
-}       
+}
 
 inline void* CopyVisitor::allocateNewSpaceSlow(size_t bytes)
 {
diff --git a/Source/JavaScriptCore/heap/MarkedBlock.cpp b/Source/JavaScriptCore/heap/MarkedBlock.cpp
index 9a036f8..1ca7edc 100644
--- a/Source/JavaScriptCore/heap/MarkedBlock.cpp
+++ b/Source/JavaScriptCore/heap/MarkedBlock.cpp
@@ -28,7 +28,7 @@
 
 #include "IncrementalSweeper.h"
 #include "JSCell.h"
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 
 
 namespace JSC {
@@ -171,17 +171,17 @@ void MarkedBlock::canonicalizeCellLivenessData(const FreeList& freeList)
         // 2) It may have dead objects, and we only know them to be dead by the
         //    fact that their mark bits are unset.
         // Hence if the block is Marked we need to leave it Marked.
-        
+
         ASSERT(!head);
         return;
     }
-   
+
     ASSERT(m_state == FreeListed);
-    
+
     // Roll back to a coherent state for Heap introspection. Cells newly
     // allocated from our free list are not currently marked, so we need another
-    // way to tell what's live vs dead. 
-    
+    // way to tell what's live vs dead.
+
     ASSERT(!m_newlyAllocated);
     m_newlyAllocated = adoptPtr(new WTF::Bitmap<atomsPerBlock>());
 
@@ -194,7 +194,7 @@ void MarkedBlock::canonicalizeCellLivenessData(const FreeList& freeList)
         reinterpret_cast<JSCell*>(current)->zap();
         clearNewlyAllocated(current);
     }
-    
+
     m_state = Marked;
 }
 
diff --git a/Source/JavaScriptCore/heap/SlotVisitor.cpp b/Source/JavaScriptCore/heap/SlotVisitor.cpp
index 3ff4b48..08c5cad 100644
--- a/Source/JavaScriptCore/heap/SlotVisitor.cpp
+++ b/Source/JavaScriptCore/heap/SlotVisitor.cpp
@@ -7,7 +7,6 @@
 #include "CopiedSpaceInlines.h"
 #include "GCThread.h"
 #include "JSArray.h"
-#include "JSDestructibleObject.h"
 #include "JSGlobalData.h"
 #include "JSObject.h"
 #include "JSString.h"
@@ -75,7 +74,7 @@ ALWAYS_INLINE static void visitChildren(SlotVisitor& visitor, const JSCell* cell
 #endif
 
     ASSERT(Heap::isMarked(cell));
-    
+
     if (isJSString(cell)) {
         JSString::visitChildren(const_cast<JSCell*>(cell), visitor);
         return;
@@ -126,7 +125,7 @@ void SlotVisitor::drain()
 {
     StackStats::probe();
     ASSERT(m_isInParallelMode);
-   
+
 #if ENABLE(PARALLEL_GC)
     if (Options::numberOfGCMarkers() > 1) {
         while (!m_stack.isEmpty()) {
@@ -135,12 +134,12 @@ void SlotVisitor::drain()
                 visitChildren(*this, m_stack.removeLast());
             donateKnownParallel();
         }
-        
+
         mergeOpaqueRootsIfNecessary();
         return;
     }
 #endif
-    
+
     while (!m_stack.isEmpty()) {
         m_stack.refill();
         while (m_stack.canRemoveLast())
@@ -152,9 +151,9 @@ void SlotVisitor::drainFromShared(SharedDrainMode sharedDrainMode)
 {
     StackStats::probe();
     ASSERT(m_isInParallelMode);
-    
+
     ASSERT(Options::numberOfGCMarkers());
-    
+
     bool shouldBeParallel;
 
 #if ENABLE(PARALLEL_GC)
@@ -163,7 +162,7 @@ void SlotVisitor::drainFromShared(SharedDrainMode sharedDrainMode)
     ASSERT(Options::numberOfGCMarkers() == 1);
     shouldBeParallel = false;
 #endif
-    
+
     if (!shouldBeParallel) {
         // This call should be a no-op.
         ASSERT_UNUSED(sharedDrainMode, sharedDrainMode == MasterDrain);
@@ -171,7 +170,7 @@ void SlotVisitor::drainFromShared(SharedDrainMode sharedDrainMode)
         ASSERT(m_shared.m_sharedMarkStack.isEmpty());
         return;
     }
-    
+
 #if ENABLE(PARALLEL_GC)
     {
         MutexLocker locker(m_shared.m_markingLock);
@@ -193,34 +192,34 @@ void SlotVisitor::drainFromShared(SharedDrainMode sharedDrainMode)
                         m_shared.m_markingCondition.broadcast();
                         return;
                     }
-                    
+
                     // Is there work to be done?
                     if (!m_shared.m_sharedMarkStack.isEmpty())
                         break;
-                    
+
                     // Otherwise wait.
                     m_shared.m_markingCondition.wait(m_shared.m_markingLock);
                 }
             } else {
                 ASSERT(sharedDrainMode == SlaveDrain);
-                
+
                 // Did we detect termination? If so, let the master know.
                 if (!m_shared.m_numberOfActiveParallelMarkers && m_shared.m_sharedMarkStack.isEmpty())
                     m_shared.m_markingCondition.broadcast();
-                
+
                 while (m_shared.m_sharedMarkStack.isEmpty() && !m_shared.m_parallelMarkersShouldExit)
                     m_shared.m_markingCondition.wait(m_shared.m_markingLock);
-                
+
                 // Is the current phase done? If so, return from this function.
                 if (m_shared.m_parallelMarkersShouldExit)
                     return;
             }
-           
+
             size_t idleThreadCount = Options::numberOfGCMarkers() - m_shared.m_numberOfActiveParallelMarkers;
             m_stack.stealSomeCellsFrom(m_shared.m_sharedMarkStack, idleThreadCount);
             m_shared.m_numberOfActiveParallelMarkers++;
         }
-        
+
         drain();
     }
 #endif
diff --git a/Source/JavaScriptCore/runtime/Arguments.h b/Source/JavaScriptCore/runtime/Arguments.h
index 8ae9914..567e3eb 100644
--- a/Source/JavaScriptCore/runtime/Arguments.h
+++ b/Source/JavaScriptCore/runtime/Arguments.h
@@ -26,7 +26,7 @@
 
 #include "CodeOrigin.h"
 #include "JSActivation.h"
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 #include "JSFunction.h"
 #include "JSGlobalObject.h"
 #include "Interpreter.h"
@@ -46,7 +46,7 @@ public:
         arguments->finishCreation(callFrame);
         return arguments;
     }
-        
+
     static Arguments* create(JSGlobalData& globalData, CallFrame* callFrame, InlineCallFrame* inlineCallFrame)
     {
         Arguments* arguments = new (NotNull, allocateCell<Arguments>(globalData.heap)) Arguments(callFrame);
@@ -58,10 +58,10 @@ public:
 
 private:
     enum NoParametersType { NoParameters };
-        
+
     Arguments(CallFrame*);
     Arguments(CallFrame*, NoParametersType);
-        
+
     void tearOffForInlineCallFrame(JSGlobalData& globalData, Register*, InlineCallFrame*);
 
 public:
@@ -71,24 +71,24 @@ public:
 
     void fillArgList(ExecState*, MarkedArgumentBuffer&);
 
-    uint32_t length(ExecState* exec) const 
+    uint32_t length(ExecState* exec) const
     {
         if (UNLIKELY(m_overrodeLength))
             return get(exec, exec->propertyNames().length).toUInt32(exec);
-        return m_numArguments; 
+        return m_numArguments;
     }
-        
+
     void copyToArguments(ExecState*, CallFrame*, uint32_t length);
     void tearOff(CallFrame*);
     void tearOff(CallFrame*, InlineCallFrame*);
     bool isTornOff() const { return m_registerArray; }
     void didTearOffActivation(ExecState*, JSActivation*);
 
-    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype) 
-    { 
-        return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info); 
+    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
+    {
+        return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
     }
-        
+
 protected:
     static const unsigned StructureFlags = OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesVisitChildren | OverridesGetPropertyNames | JSObject::StructureFlags;
 
@@ -126,7 +126,7 @@ private:
     // We make these full byte booleans to make them easy to test from the JIT,
     // and because even if they were single-bit booleans we still wouldn't save
     // any space.
-    bool m_overrodeLength; 
+    bool m_overrodeLength;
     bool m_overrodeCallee;
     bool m_overrodeCaller;
     bool m_isStrictMode;
diff --git a/Source/JavaScriptCore/runtime/InternalFunction.h b/Source/JavaScriptCore/runtime/InternalFunction.h
index daeebc3..3ed4f39 100644
--- a/Source/JavaScriptCore/runtime/InternalFunction.h
+++ b/Source/JavaScriptCore/runtime/InternalFunction.h
@@ -25,7 +25,7 @@
 #define InternalFunction_h
 
 #include "Identifier.h"
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 
 namespace JSC {
 
@@ -41,9 +41,9 @@ namespace JSC {
         const String displayName(ExecState*);
         const String calculatedDisplayName(ExecState*);
 
-        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) 
-        { 
-            return Structure::create(globalData, globalObject, proto, TypeInfo(ObjectType, StructureFlags), &s_info); 
+        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
+        {
+            return Structure::create(globalData, globalObject, proto, TypeInfo(ObjectType, StructureFlags), &s_info);
         }
 
     protected:
diff --git a/Source/JavaScriptCore/runtime/JSFunction.h b/Source/JavaScriptCore/runtime/JSFunction.h
index 322ee58..05453f9 100644
--- a/Source/JavaScriptCore/runtime/JSFunction.h
+++ b/Source/JavaScriptCore/runtime/JSFunction.h
@@ -25,7 +25,7 @@
 #define JSFunction_h
 
 #include "InternalFunction.h"
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 #include "JSScope.h"
 #include "Watchpoint.h"
 
@@ -47,7 +47,7 @@ namespace JSC {
     JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL callHostFunctionAsConstructor(ExecState*);
 
     JS_EXPORT_PRIVATE String getCalculatedDisplayName(CallFrame*, JSObject*);
-    
+
     class JSFunction : public JSDestructibleObject {
         friend class JIT;
         friend class DFG::SpeculativeJIT;
@@ -67,9 +67,9 @@ namespace JSC {
             function->finishCreation(globalData);
             return function;
         }
-        
+
         static void destroy(JSCell*);
-        
+
         JS_EXPORT_PRIVATE String name(ExecState*);
         JS_EXPORT_PRIVATE String displayName(ExecState*);
         const String calculatedDisplayName(ExecState*);
@@ -104,10 +104,10 @@ namespace JSC {
 
         static JS_EXPORTDATA const ClassInfo s_info;
 
-        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype) 
+        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
         {
             ASSERT(globalObject);
-            return Structure::create(globalData, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), &s_info); 
+            return Structure::create(globalData, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), &s_info);
         }
 
         NativeFunction nativeFunction();
@@ -141,7 +141,7 @@ namespace JSC {
                 return 0;
             return m_cachedInheritorID.get();
         }
-        
+
         void addInheritorIDWatchpoint(Watchpoint* watchpoint)
         {
             ASSERT(tryGetKnownInheritorID());
@@ -158,7 +158,7 @@ namespace JSC {
 
         JS_EXPORT_PRIVATE JSFunction(ExecState*, JSGlobalObject*, Structure*);
         JSFunction(JSGlobalData&, FunctionExecutable*, JSScope*);
-        
+
         void finishCreation(ExecState*, NativeExecutable*, int length, const String& name);
         using Base::finishCreation;
 
@@ -177,7 +177,7 @@ namespace JSC {
 
     private:
         friend class LLIntOffsetsExtractor;
-        
+
         JS_EXPORT_PRIVATE bool isHostFunctionNonInline() const;
 
         static JSValue argumentsGetter(ExecState*, JSValue, PropertyName);
diff --git a/Source/JavaScriptCore/runtime/JSObject.h b/Source/JavaScriptCore/runtime/JSObject.h
index 4f7f470..d787bbe 100644
--- a/Source/JavaScriptCore/runtime/JSObject.h
+++ b/Source/JavaScriptCore/runtime/JSObject.h
@@ -109,12 +109,12 @@ class JSObject : public JSCell {
 
 public:
     typedef JSCell Base;
-        
+
     static size_t allocationSize(size_t inlineCapacity)
     {
         return sizeof(JSObject) + inlineCapacity * sizeof(WriteBarrierBase<Unknown>);
     }
-        
+
     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&);
     JS_EXPORT_PRIVATE static void copyBackingStore(JSCell*, CopyVisitor&);
 
@@ -123,20 +123,20 @@ public:
     JSValue prototype() const;
     void setPrototype(JSGlobalData&, JSValue prototype);
     bool setPrototypeWithCycleCheck(JSGlobalData&, JSValue prototype);
-        
+
     Structure* inheritorID(JSGlobalData&);
     void notifyUsedAsPrototype(JSGlobalData&);
-        
+
     bool mayBeUsedAsPrototype(JSGlobalData& globalData)
     {
         return isValidOffset(structure()->get(globalData, globalData.m_inheritorIDKey));
     }
-        
+
     bool mayInterceptIndexedAccesses()
     {
         return structure()->mayInterceptIndexedAccesses();
     }
-        
+
     JSValue get(ExecState*, PropertyName) const;
     JSValue get(ExecState*, unsigned propertyName) const;
 
@@ -156,17 +156,17 @@ public:
             return 0;
         return m_butterfly->publicLength();
     }
-        
+
     unsigned getVectorLength()
     {
         if (!hasIndexedProperties(structure()->indexingType()))
             return 0;
         return m_butterfly->vectorLength();
     }
-        
+
     JS_EXPORT_PRIVATE static void put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&);
     JS_EXPORT_PRIVATE static void putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
-        
+
     void putByIndexInline(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
     {
         if (canSetIndexQuickly(propertyName)) {
@@ -175,7 +175,7 @@ public:
         }
         methodTable()->putByIndex(this, exec, propertyName, value, shouldThrow);
     }
-        
+
     // This is similar to the putDirect* methods:
     //  - the prototype chain is not consulted
     //  - accessors are not called.
@@ -196,7 +196,7 @@ public:
 
     // A non-throwing version of putDirect and putDirectIndex.
     JS_EXPORT_PRIVATE void putDirectMayBeIndex(ExecState*, PropertyName, JSValue);
-        
+
     bool canGetIndexQuickly(unsigned i)
     {
         switch (structure()->indexingType()) {
@@ -221,7 +221,7 @@ public:
             return false;
         }
     }
-        
+
     JSValue getIndexQuickly(unsigned i)
     {
         switch (structure()->indexingType()) {
@@ -237,7 +237,7 @@ public:
             return JSValue();
         }
     }
-        
+
     JSValue tryGetIndexQuickly(unsigned i)
     {
         switch (structure()->indexingType()) {
@@ -267,7 +267,7 @@ public:
         }
         return JSValue();
     }
-        
+
     JSValue getDirectIndex(ExecState* exec, unsigned i)
     {
         if (JSValue result = tryGetIndexQuickly(i))
@@ -277,14 +277,14 @@ public:
             return slot.getValue(exec, i);
         return JSValue();
     }
-        
+
     JSValue getIndex(ExecState* exec, unsigned i)
     {
         if (JSValue result = tryGetIndexQuickly(i))
             return result;
         return get(exec, i);
     }
-        
+
     bool canSetIndexQuickly(unsigned i)
     {
         switch (structure()->indexingType()) {
@@ -306,7 +306,7 @@ public:
             return false;
         }
     }
-        
+
     bool canSetIndexQuicklyForPutDirect(unsigned i)
     {
         switch (structure()->indexingType()) {
@@ -323,7 +323,7 @@ public:
             return false;
         }
     }
-        
+
     void setIndexQuickly(JSGlobalData& globalData, unsigned i, JSValue v)
     {
         switch (structure()->indexingType()) {
@@ -374,7 +374,7 @@ public:
             ASSERT_NOT_REACHED();
         }
     }
-        
+
     void initializeIndex(JSGlobalData& globalData, unsigned i, JSValue v)
     {
         switch (structure()->indexingType()) {
@@ -423,7 +423,7 @@ public:
             ASSERT_NOT_REACHED();
         }
     }
-        
+
     bool hasSparseMap()
     {
         switch (structure()->indexingType()) {
@@ -440,7 +440,7 @@ public:
             return false;
         }
     }
-        
+
     bool inSparseIndexingMode()
     {
         switch (structure()->indexingType()) {
@@ -457,7 +457,7 @@ public:
             return false;
         }
     }
-        
+
     void enterDictionaryIndexingMode(JSGlobalData&);
 
     // putDirect is effectively an unchecked vesion of 'defineOwnProperty':
@@ -541,10 +541,10 @@ public:
         ASSERT(hasInlineStorage());
         return inlineStorageUnsafe();
     }
-        
+
     const Butterfly* butterfly() const { return m_butterfly; }
     Butterfly* butterfly() { return m_butterfly; }
-        
+
     ConstPropertyStorage outOfLineStorage() const { return m_butterfly->propertyStorage(); }
     PropertyStorage outOfLineStorage() { return m_butterfly->propertyStorage(); }
 
@@ -618,7 +618,7 @@ public:
     JS_EXPORT_PRIVATE Butterfly* growOutOfLineStorage(JSGlobalData&, size_t oldSize, size_t newSize);
     void setButterfly(JSGlobalData&, Butterfly*, Structure*);
     void setButterflyWithoutChangingStructure(Butterfly*); // You probably don't want to call this.
-        
+
     void setStructureAndReallocateStorageIfNecessary(JSGlobalData&, unsigned oldCapacity, Structure*);
     void setStructureAndReallocateStorageIfNecessary(JSGlobalData&, Structure*);
 
@@ -633,9 +633,9 @@ public:
         ASSERT(!isGlobalObject() || ((JSObject*)structure()->globalObject()) == this);
         return structure()->globalObject();
     }
-        
+
     void switchToSlowPutArrayStorage(JSGlobalData&);
-        
+
     // The receiver is the prototype in this case. The following:
     //
     // asObject(foo->structure()->storedPrototype())->attemptToInterceptPutByIndexOnHoleForPrototype(...)
@@ -644,7 +644,7 @@ public:
     //
     // foo->attemptToInterceptPutByIndexOnHole(...);
     bool attemptToInterceptPutByIndexOnHoleForPrototype(ExecState*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow);
-        
+
     // Returns 0 if int32 storage cannot be created - either because
     // indexing should be sparse, we're having a bad time, or because
     // we already have a more general form of storage (double,
@@ -653,10 +653,10 @@ public:
     {
         if (LIKELY(hasInt32(structure()->indexingType())))
             return m_butterfly->contiguousInt32();
-            
+
         return ensureInt32Slow(globalData);
     }
-        
+
     // Returns 0 if double storage cannot be created - either because
     // indexing should be sparse, we're having a bad time, or because
     // we already have a more general form of storage (contiguous,
@@ -665,20 +665,20 @@ public:
     {
         if (LIKELY(hasDouble(structure()->indexingType())))
             return m_butterfly->contiguousDouble();
-            
+
         return ensureDoubleSlow(globalData);
     }
-        
+
     // Returns 0 if contiguous storage cannot be created - either because
     // indexing should be sparse or because we're having a bad time.
     WriteBarrier<Unknown>* ensureContiguous(JSGlobalData& globalData)
     {
         if (LIKELY(hasContiguous(structure()->indexingType())))
             return m_butterfly->contiguous();
-            
+
         return ensureContiguousSlow(globalData);
     }
-        
+
     // Ensure that the object is in a mode where it has array storage. Use
     // this if you're about to perform actions that would have required the
     // object to be converted to have array storage, if it didn't have it
@@ -687,17 +687,17 @@ public:
     {
         if (LIKELY(hasArrayStorage(structure()->indexingType())))
             return m_butterfly->arrayStorage();
-            
+
         return ensureArrayStorageSlow(globalData);
     }
-        
+
     static size_t offsetOfInlineStorage();
-        
+
     static ptrdiff_t butterflyOffset()
     {
         return OBJECT_OFFSETOF(JSObject, m_butterfly);
     }
-        
+
     void* butterflyAddress()
     {
         return &m_butterfly;
@@ -725,9 +725,9 @@ protected:
     // To instantiate objects you likely want JSFinalObject, below.
     // To create derived types you likely want JSNonFinalObject, below.
     JSObject(JSGlobalData&, Structure*, Butterfly* = 0);
-        
+
     void resetInheritorID(JSGlobalData&);
-        
+
     void visitButterfly(SlotVisitor&, Butterfly*, size_t storageSize);
     void copyButterfly(CopyVisitor&, Butterfly*, size_t storageSize);
 
@@ -738,7 +738,7 @@ protected:
         ASSERT(hasArrayStorage(structure()->indexingType()));
         return m_butterfly->arrayStorage();
     }
-        
+
     // Call this if you want to predicate some actions on whether or not the
     // object is in a mode where it has array storage.
     ArrayStorage* arrayStorageOrNull()
@@ -746,48 +746,48 @@ protected:
         switch (structure()->indexingType()) {
         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
             return m_butterfly->arrayStorage();
-                
+
         default:
             return 0;
         }
     }
-        
+
     Butterfly* createInitialUndecided(JSGlobalData&, unsigned length);
     WriteBarrier<Unknown>* createInitialInt32(JSGlobalData&, unsigned length);
     double* createInitialDouble(JSGlobalData&, unsigned length);
     WriteBarrier<Unknown>* createInitialContiguous(JSGlobalData&, unsigned length);
-        
+
     void convertUndecidedForValue(JSGlobalData&, JSValue);
     void convertInt32ForValue(JSGlobalData&, JSValue);
-        
+
     ArrayStorage* createArrayStorage(JSGlobalData&, unsigned length, unsigned vectorLength);
     ArrayStorage* createInitialArrayStorage(JSGlobalData&);
-        
+
     WriteBarrier<Unknown>* convertUndecidedToInt32(JSGlobalData&);
     double* convertUndecidedToDouble(JSGlobalData&);
     WriteBarrier<Unknown>* convertUndecidedToContiguous(JSGlobalData&);
     ArrayStorage* convertUndecidedToArrayStorage(JSGlobalData&, NonPropertyTransition, unsigned neededLength);
     ArrayStorage* convertUndecidedToArrayStorage(JSGlobalData&, NonPropertyTransition);
     ArrayStorage* convertUndecidedToArrayStorage(JSGlobalData&);
-        
+
     double* convertInt32ToDouble(JSGlobalData&);
     WriteBarrier<Unknown>* convertInt32ToContiguous(JSGlobalData&);
     ArrayStorage* convertInt32ToArrayStorage(JSGlobalData&, NonPropertyTransition, unsigned neededLength);
     ArrayStorage* convertInt32ToArrayStorage(JSGlobalData&, NonPropertyTransition);
     ArrayStorage* convertInt32ToArrayStorage(JSGlobalData&);
-        
+
     WriteBarrier<Unknown>* convertDoubleToContiguous(JSGlobalData&);
     ArrayStorage* convertDoubleToArrayStorage(JSGlobalData&, NonPropertyTransition, unsigned neededLength);
     ArrayStorage* convertDoubleToArrayStorage(JSGlobalData&, NonPropertyTransition);
     ArrayStorage* convertDoubleToArrayStorage(JSGlobalData&);
-        
+
     ArrayStorage* convertContiguousToArrayStorage(JSGlobalData&, NonPropertyTransition, unsigned neededLength);
     ArrayStorage* convertContiguousToArrayStorage(JSGlobalData&, NonPropertyTransition);
     ArrayStorage* convertContiguousToArrayStorage(JSGlobalData&);
 
-        
+
     ArrayStorage* ensureArrayStorageExistsAndEnterDictionaryIndexingMode(JSGlobalData&);
-        
+
     bool defineOwnNonIndexProperty(ExecState*, PropertyName, PropertyDescriptor&, bool throwException);
 
     template<IndexingType indexingShape>
@@ -798,31 +798,31 @@ protected:
     void deallocateSparseIndexMap();
     bool defineOwnIndexedProperty(ExecState*, unsigned, PropertyDescriptor&, bool throwException);
     SparseArrayValueMap* allocateSparseIndexMap(JSGlobalData&);
-        
+
     void notifyPresenceOfIndexedAccessors(JSGlobalData&);
-        
+
     bool attemptToInterceptPutByIndexOnHole(ExecState*, unsigned index, JSValue, bool shouldThrow);
-        
+
     // Call this if you want setIndexQuickly to succeed and you're sure that
     // the array is contiguous.
     void ensureLength(JSGlobalData& globalData, unsigned length)
     {
         ASSERT(length < MAX_ARRAY_INDEX);
         ASSERT(hasContiguous(structure()->indexingType()) || hasInt32(structure()->indexingType()) || hasDouble(structure()->indexingType()) || hasUndecided(structure()->indexingType()));
-            
+
         if (m_butterfly->vectorLength() < length)
             ensureLengthSlow(globalData, length);
-            
+
         if (m_butterfly->publicLength() < length)
             m_butterfly->setPublicLength(length);
     }
-        
+
     template<IndexingType indexingShape>
     unsigned countElements(Butterfly*);
-        
+
     // This is relevant to undecided, int32, double, and contiguous.
     unsigned countElements();
-        
+
     // This strange method returns a pointer to the start of the indexed data
     // as if it contained JSValues. But it won't always contain JSValues.
     // Make sure you cast this to the appropriate type before using.
@@ -834,10 +834,10 @@ protected:
         case ALL_DOUBLE_INDEXING_TYPES:
         case ALL_CONTIGUOUS_INDEXING_TYPES:
             return m_butterfly->contiguous();
-                
+
         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
             return m_butterfly->arrayStorage()->m_vector;
-                
+
         default:
             CRASH();
             return 0;
@@ -859,7 +859,7 @@ protected:
             return 0;
         }
     }
-        
+
     JSValue getHolyIndexQuickly(unsigned i)
     {
         switch (structure()->indexingType()) {
@@ -879,7 +879,7 @@ protected:
             return JSValue();
         }
     }
-        
+
     template<IndexingType indexingType>
     unsigned relevantLength()
     {
@@ -888,12 +888,12 @@ protected:
         case ALL_DOUBLE_INDEXING_TYPES:
         case ALL_CONTIGUOUS_INDEXING_TYPES:
             return m_butterfly->publicLength();
-                
+
         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
             return std::min(
                 m_butterfly->arrayStorage()->length(),
                 m_butterfly->arrayStorage()->vectorLength());
-                
+
         default:
             CRASH();
             return 0;
@@ -921,7 +921,7 @@ protected:
 
 private:
     friend class LLIntOffsetsExtractor;
-        
+
     // Nobody should ever ask any of these questions on something already known to be a JSObject.
     using JSCell::isAPIValueWrapper;
     using JSCell::isGetterSetter;
@@ -929,11 +929,11 @@ private:
     void getString(ExecState* exec);
     void isObject();
     void isString();
-        
+
     Butterfly* createInitialIndexedStorage(JSGlobalData&, unsigned length, size_t elementSize);
-        
+
     ArrayStorage* enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(JSGlobalData&, ArrayStorage*);
-        
+
     template<PutMode>
     bool putDirectInternal(JSGlobalData&, PropertyName, JSValue, unsigned attr, PutPropertySlot&, JSCell*);
 
@@ -942,31 +942,31 @@ private:
 
     const HashEntry* findPropertyHashEntry(ExecState*, PropertyName) const;
     Structure* createInheritorID(JSGlobalData&);
-        
+
     void putIndexedDescriptor(ExecState*, SparseArrayEntry*, PropertyDescriptor&, PropertyDescriptor& old);
-        
+
     void putByIndexBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
     bool putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);
     JS_EXPORT_PRIVATE bool putDirectIndexBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);
-        
+
     unsigned getNewVectorLength(unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength);
     unsigned getNewVectorLength(unsigned desiredLength);
 
     JS_EXPORT_PRIVATE bool getOwnPropertySlotSlow(ExecState*, PropertyName, PropertySlot&);
-        
+
     ArrayStorage* constructConvertedArrayStorageWithoutCopyingElements(JSGlobalData&, unsigned neededLength);
-        
+
     JS_EXPORT_PRIVATE void setIndexQuicklyToUndecided(JSGlobalData&, unsigned index, JSValue);
     JS_EXPORT_PRIVATE void convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(JSGlobalData&, unsigned index, JSValue);
     JS_EXPORT_PRIVATE void convertDoubleToContiguousWhilePerformingSetIndex(JSGlobalData&, unsigned index, JSValue);
-        
+
     void ensureLengthSlow(JSGlobalData&, unsigned length);
-        
+
     WriteBarrier<Unknown>* ensureInt32Slow(JSGlobalData&);
     double* ensureDoubleSlow(JSGlobalData&);
     WriteBarrier<Unknown>* ensureContiguousSlow(JSGlobalData&);
     ArrayStorage* ensureArrayStorageSlow(JSGlobalData&);
-        
+
 protected:
     Butterfly* m_butterfly;
 };
@@ -1022,7 +1022,7 @@ public:
 
 protected:
     void visitChildrenCommon(SlotVisitor&);
-        
+
     void finishCreation(JSGlobalData& globalData)
     {
         Base::finishCreation(globalData);
@@ -1044,7 +1044,7 @@ private:
 inline JSFinalObject* JSFinalObject::create(ExecState* exec, Structure* structure)
 {
     JSFinalObject* finalObject = new (
-        NotNull, 
+        NotNull,
         allocateCell<JSFinalObject>(
             *exec->heap(),
             allocationSize(structure->inlineCapacity())
@@ -1253,7 +1253,7 @@ inline JSValue JSObject::get(ExecState* exec, PropertyName propertyName) const
     PropertySlot slot(this);
     if (const_cast<JSObject*>(this)->getPropertySlot(exec, propertyName, slot))
         return slot.getValue(exec, propertyName);
-    
+
     return jsUndefined();
 }
 
@@ -1372,7 +1372,7 @@ inline bool JSObject::putDirectInternal(JSGlobalData& globalData, PropertyName p
         return false;
 
     Structure* structure = Structure::addPropertyTransition(globalData, this->structure(), propertyName, attributes, specificFunction, offset);
-    
+
     validateOffset(offset);
     ASSERT(structure->isValidOffset(offset));
     setStructureAndReallocateStorageIfNecessary(globalData, structure);
@@ -1390,12 +1390,12 @@ inline bool JSObject::putDirectInternal(JSGlobalData& globalData, PropertyName p
 inline void JSObject::setStructureAndReallocateStorageIfNecessary(JSGlobalData& globalData, unsigned oldCapacity, Structure* newStructure)
 {
     ASSERT(oldCapacity <= newStructure->outOfLineCapacity());
-    
+
     if (oldCapacity == newStructure->outOfLineCapacity()) {
         setStructure(globalData, newStructure);
         return;
     }
-    
+
     Butterfly* newButterfly = growOutOfLineStorage(
         globalData, oldCapacity, newStructure->outOfLineCapacity());
     setButterfly(globalData, newButterfly, newStructure);
@@ -1560,6 +1560,51 @@ inline int offsetRelativeToBase(PropertyOffset offset)
 
 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase<Unknown>)), JSObject_inline_storage_has_correct_alignment);
 
+
+/* XXX XXX XXX XXX XXX XXX XXX XXX
+ *
+ * Merged content of JSDestructibleObject.h
+ *
+ * Done at behest of https://bugs.webkit.org/show_bug.cgi?id=100592#c6
+ * to prevent a very odd compiler/linker bug due to "externally" defined
+ * inline classmethod.
+ *
+ * XXX XXX XXX XXX XXX XXX XXX XXX
+ *
+ */
+
+class JSDestructibleObject : public JSNonFinalObject {
+public:
+    typedef JSNonFinalObject Base;
+
+    static const bool needsDestruction = true;
+
+    const ClassInfo* classInfo() const { return m_classInfo; }
+
+protected:
+    JSDestructibleObject(JSGlobalData& globalData, Structure* structure, Butterfly* butterfly = 0)
+        : JSNonFinalObject(globalData, structure, butterfly)
+        , m_classInfo(structure->classInfo())
+    {
+        ASSERT(m_classInfo);
+    }
+
+private:
+    const ClassInfo* m_classInfo;
+};
+
+inline const ClassInfo* JSCell::classInfo() const
+{
+    if (MarkedBlock::blockFor(this)->destructorType() == MarkedBlock::Normal)
+        return static_cast<const JSDestructibleObject*>(this)->classInfo();
+#if ENABLE(GC_VALIDATION)
+    return m_structure.unvalidatedGet()->classInfo();
+#else
+    return m_structure->classInfo();
+#endif
+}
+
+
 } // namespace JSC
 
 #endif // JSObject_h
diff --git a/Source/JavaScriptCore/runtime/JSProxy.h b/Source/JavaScriptCore/runtime/JSProxy.h
index 144085a..d0272e8 100644
--- a/Source/JavaScriptCore/runtime/JSProxy.h
+++ b/Source/JavaScriptCore/runtime/JSProxy.h
@@ -20,13 +20,13 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef JSProxy_h
 #define JSProxy_h
 
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 
 namespace JSC {
 
diff --git a/Source/JavaScriptCore/runtime/JSWrapperObject.h b/Source/JavaScriptCore/runtime/JSWrapperObject.h
index 72bc187..b815f85 100644
--- a/Source/JavaScriptCore/runtime/JSWrapperObject.h
+++ b/Source/JavaScriptCore/runtime/JSWrapperObject.h
@@ -22,7 +22,7 @@
 #ifndef JSWrapperObject_h
 #define JSWrapperObject_h
 
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 
 namespace JSC {
 
@@ -35,8 +35,8 @@ namespace JSC {
         JSValue internalValue() const;
         void setInternalValue(JSGlobalData&, JSValue);
 
-        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype) 
-        { 
+        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
+        {
             return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
         }
 
diff --git a/Source/JavaScriptCore/runtime/NameInstance.h b/Source/JavaScriptCore/runtime/NameInstance.h
index 129e7c4..ad44873 100644
--- a/Source/JavaScriptCore/runtime/NameInstance.h
+++ b/Source/JavaScriptCore/runtime/NameInstance.h
@@ -26,7 +26,7 @@
 #ifndef NameInstance_h
 #define NameInstance_h
 
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 #include "PrivateName.h"
 
 namespace JSC {
diff --git a/Source/WebCore/ForwardingHeaders/runtime/JSDestructibleObject.h b/Source/WebCore/ForwardingHeaders/runtime/JSDestructibleObject.h
index 196a6f9..68119ef 100644
--- a/Source/WebCore/ForwardingHeaders/runtime/JSDestructibleObject.h
+++ b/Source/WebCore/ForwardingHeaders/runtime/JSDestructibleObject.h
@@ -1,4 +1,4 @@
 #ifndef WebCore_FWD_JSDestructibleObject_h
 #define WebCore_FWD_JSDestructibleObject_h
-#include <JavaScriptCore/JSDestructibleObject.h>
+#include <JavaScriptCore/JSObject.h>
 #endif
diff --git a/Source/WebCore/bindings/js/JSDOMWrapper.h b/Source/WebCore/bindings/js/JSDOMWrapper.h
index ad95f0f..32394fe 100644
--- a/Source/WebCore/bindings/js/JSDOMWrapper.h
+++ b/Source/WebCore/bindings/js/JSDOMWrapper.h
@@ -23,7 +23,7 @@
 #define JSDOMWrapper_h
 
 #include "JSDOMGlobalObject.h"
-#include <runtime/JSDestructibleObject.h>
+#include <runtime/JSObject.h>
 
 namespace WebCore {
 
@@ -37,7 +37,7 @@ public:
     ScriptExecutionContext* scriptExecutionContext() const { return globalObject()->scriptExecutionContext(); }
 
 protected:
-    JSDOMWrapper(JSC::Structure* structure, JSC::JSGlobalObject* globalObject) 
+    JSDOMWrapper(JSC::Structure* structure, JSC::JSGlobalObject* globalObject)
         : JSDestructibleObject(globalObject->globalData(), structure)
     {
         ASSERT(scriptExecutionContext());
-- 
1.7.10.4

